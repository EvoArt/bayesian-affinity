
Code and data from [Bayesian estimation of co-occurrence affinity via dyadic regression](https://www.biorxiv.org/content/10.1101/2024.01.16.575941v1). Code tested on Julia-1.10.9. For accompanying software package see https://github.com/EvoArt/CooccurrenceRegression.jl.

# Simulated data

All code used for analysis and plotting is included in a single file `src.jl`

# Examples with real data 

All data, intermediate and final results are contained in this repository. However, for those interested in replicating the analyses, the majority of the code is contained in quarto .qmd files (for ease of comparing mathematical models with actual implementations) which were run using the [native Julia engine](https://github.com/PumasAI/QuartoNotebookRunner.jl). Though, the code can obviously be copied and pasted into the Julia REPL. All qmd files can be run independently, with the exception that figures.qmd requires data generated by ants_dist.jl, ants_traits.qmd, beetles.qmd and microbes.qmd, and microbes.qmd depends on data from data_processing_microbes.qmd. Ant phylogenetic analyses (ants_genus.jl and ants_species.jl) depend on a distance matrix generated in ants_dist.jl. These are in plain Julia .jl files, due to longer computation times making them more suitable to running on HPC clusters. 

## Running scripts individually

The results shown in Figure 3 of the manuscript can be obtained by running beetles.qmd.

The results shown in Figure 4 of the manuscript can be obtained by running ants_traits.qmd, ants_dist.jl, ants_genus.jl and ants_species.jl, in that order.

The results shown in Figure 5 of the manuscript can be obtained by running data_processing_microbes.qmd and microbes.qmd, in that order.

## Running all code automatically

The script run_all_examples.jl will automatically run analyses except for ants_genus.jl and ants_species.jl, in a suitable order.

The bash script ants_phylo.sh can be used to run ants_genus.jl and ants_species.jl on a SLURM cluster.

## Figures

The figures can then be produced by running figures.qmd interactively to ensure output is satisfactory before saving.

## Notes on analysis code

In the probabilistic programming language Turing.jl, the basic model structure:

$$
\begin{aligned}
K_{ij} &\sim \text{fnchypg}(\vec{m}_{i},N-\vec{m}_{i},\vec{m}_{j},e^{\alpha})\\
\alpha &= \beta_{0} + \lambda_{i} + \lambda_{j} + \beta X\\
\beta_{k} &\sim \text{N}(0,1)\\
\beta_{0} &\sim \text{N}(0,4)\\
\lambda_{i} &\sim \text{N}(0,1),\\
\end{aligned}
$$ 

would be given by

```{julia}
@model function basic_model(X,k, n_obs,N,m)
    λ ~ filldist(Normal(0.0,1.0),n_obs)
    β ~ Normal(0.0,1.0)
    β₀ ~ Normal(0.0,4.0)
    for j in 1:n_obs-1
        mB = m[j]
        for i in j+1:n_obs
            mA = m[i]
            α = β₀ + β * X[i,j] + λ[i] + λ[j]
            k[i,j] ~ FisherNoncentralHypergeometric(mA,N-mA,mB,exp(α))
        end
    end
end
```

However, I found the following implementation (accumulating the log probability manually) to be more efficient, at least in conjunction with the Mooncake automatic differentiation software.

```{julia}
@model function basic_model(X,k, n_obs,N,m)
    λ ~ filldist(Normal(0.0,1.0),n_obs)
    β ~ Normal(0.0,1.0)
    β₀ ~ Normal(0.0,4.0)
    lp = 0.0
    for j in 1:n_obs-1
        mB = m[j]
        for i in j+1:n_obs
            mA = m[i]
            α = β₀ + β * X[i,j] + λ[i] + λ[j]
            lp +=  FNCH_logpdf(mA,N-mA,mB,exp(α),k[i,j])
        end
    end
end
```

Similarly, model implementations in code are mathematically equivalent to the models presented in the text, though the implementation details are geared towards a combination of computational efficiency and ease of debugging. Whereas, the textual model definitions are aimed to be concise and informative.

Prior to analysis, any given presence absence matrix $PA$ species is converted to a parameter list containing: a matrix $k$ where $k_{i,j}$ is the number of times species $i$ and $j$ were detected together; the number of species; the number of samples/sites; a vector containing the number of samples/sites at which each species was detected at all.

```{julia}
k = zeros(Int64, n_obs,n_obs)
for i in 2:n_obs
    for j in 1:i-1
        k[i,j] = sum(PA[:,i] .* PA[:,j])
    end
end
params = k, n_obs, n_sample, vec(sum(PA, dims = 1))
```